Implementation notes for some of Fuse's systems
===============================================

Contents:

1. The main emulation loop
2. The display code
2.1. Building an image of the Spectrum's screen

1. The main emulation loop
==========================

The main emulation loop (the while loop in fuse.c:main) is essentially
fairly simple: it just runs Z80 opcodes until something `interesting'
happens, at which point it deals with the `interesting' thing.

The question here is how do we know when something `interesting' has
occured: the simple answer is that something interesting occurs when
the `tstates' global variable (which counts tstates since the last
interrupt occured) reaches `event_next_event'. It should be noted here
that these events are purely a Fuse concept, and not related to any OS
feature.

Perhaps the most obvious type of event which can occur is an
interrupt, which (on the 48K machine anyway) will occur 69888 tstates
after the last interrupt. When each interrupt occurs, the code sets
another interrupt to occur one frame later (the event_add() call in
spectrum.c:spectrum_interrupt). `event_next_event' will then be set by
the code in event.c.

TZX playback is handled in much the same way: an event (of type
EVENT_TYPE_EDGE) is scheduled to occur whenever the signal from the
(emulated) tape changes. That event then toggles the input to the
ULA's EAR bit, and schedules another event to occur whenever the next
edge is due from the tape.

RZX playback cannot be handled in the same way, as it is not known
after how many tstates the interrupt will occur. In this case, the
interrupt is forced when it is due to occur by scheduling an event
from the main Z80 emulation loop (z80/z80_ops.c:z80_do_opcodes) and
then breaking out of the loop.

2. The display code
===================

There are two stages to producing the Spectrum's screen on the
emulating machine's screen: firstly, builiding an image of the
Spectrum's screen in memory, and then translating that image onto the
emulating machine's screen.

The first of these functions is accomplished by the code in display.c,
whilst the second is fulfilled by each user interface separately,
although generally in ui/<name>/<name>display.c.

2.1. Building an image of the Spectrum's screen
-----------------------------------------------

The function of almost all the code in display.c is to build an image
of the Spectrum's screen in the display.c:display_image array. For the
`normal' (non-Timex) machines, this array has a size 320x240 and each
pixel represents one pixel on the Spectrum's screen (including 32
pixels of left and right border, and 24 pixels of top and bottom
border). For the Timex machines, this array is sized 640x480 to
accomodate the hires modes and each Spectrum pixel is represented by
two vertically adjacent pixels in the array (as the hires modes double
only the horizontal resolution, not the vertical resolution). In both
cases, the values in this array are the Spectrum colours (0 to 15).

Fuse models the process wereby the ULA/SCLD reads the screen at set
points in the frame to constuct the main screen two bytes at a time
(usually pixels + attribute, but in Timex hires mode two blocks of
pixels).

An event (of type EVENT_TYPE_DISPLAY_WRITE) is scheduled for each
point the ULA/SCLD would read the screen. When triggered, that event
converts the tstate trigger value into the current beam x and y
co-ordinates. It gets a copy of all three bytes of source data that
can affect the screen display (generally screen pixel data, attribute
byte and SCLD screen mode), and checks to see if there are any actual
changes since the display was last updated by checking the
display.c:display_last_screen array.

If so, we plot the data to the display_image array, update the
display_last_screen array with the data used to generate the update,
and mark any pixels affected by the write as 'dirty' in the
display.c:display_is_dirty array.

Each bit in each entry represents an 8 (non-Timex) or 16 (Timex) pixel
chunk of the screen plus border which must be updated. The least
significant bit represents the left-most 8 (16) pixels, the second
bit the next 8 (16) and so on.

At the end of the frame, a list of rectangles of dirty pixels is built
up from the display_is_dirty by display.c:add_rectangle() and
display.c:end_line(). Then each of these rectangles is passed off to
the user-interface specific rendering code to be drawn onto the
emulating machine's screen.

2.2. From display_image to the emulating machine's screen
---------------------------------------------------------

At the end of every frame, Fuse calls uidisplay_area repeatedly to get
the user interface to update the emulating machine's screen.

If a user interface is outputting the same number of pixels as in
display_image (320x240 for non-Timex, 640x480 for Timex), this can be
very simple, but user interfaces which implement scaling (either
upwards, or downwards as is necessary for displaying the Timex modes
in a 320x240 mode) may wish to make use of the 'scalers' defined in
ui/scaler: a generalised set of routines for accomplishing this, as
well as various smoothing options and the like (for example,
scanlines). See `scalers.txt' for more information on these.

(FIXME: write scalers.txt)

$Id$
